#ifdef NDEBUG
#undef NDEBUG
#endif // NDEBUG
// test copied from
// https://github.com/rgroshanrg/bigint/tree/main


#include "bigint.hpp"
#include <climits>
#include <cmath>        // to check for conflicts
#include <cstdlib>      // for abs of integer types
#include <map>
#include <random>
#include <cassert>
#include <numeric>
#include <iostream>



#ifndef NDEBUG
#define TEST_CASE(a,b) std::puts("reached " #a " " # b" !");
#define REQUIRE(...) do{try{assert(__VA_ARGS__);}catch(...){assert(false);}}while(false)
#define CHECK(x) if(!(x)) { std::printf("line %d check failed...",__LINE__);}
#else
#define TEST_CASE(a,b) std::puts("reached " #a " " # b" !");
#define REQUIRE(...) static_cast<void>(__VA_ARGS__)
#define CHECK(x) 

#endif
void bigint_test()
{
    using namespace zxshady;
    //12
    //6
    // 3
    // 3

    TEST_CASE("basic operations", "[functions][math][basic]")
    {
        assert((bigint(50) + bigint(32)).to_string() == "82");
        assert((bigint(5) + bigint(622)).to_string() == "627");
        assert((bigint("-33") + bigint("8")).to_string() == "-25");
        assert((bigint("15535") + bigint("0")).to_string() == "15535");
        assert((bigint("126") + bigint("39285")).to_string() == "39411");
        assert((bigint("0") + bigint("0")).to_string() == "0");
        assert(bigint(5) + 10 == 15);
        assert(bigint("-41") + 40 == -1);
        bigint ad1(600);
        ad1 += 50;
        ad1 += "50"_big;
        assert(ad1.to_string() == "700");
        assert(ad1 == 700);

        //Subtraction
        assert((bigint("50") - bigint("32")).to_string() == "18");
        assert((bigint("50") - bigint("60")).to_string() == "-10");
        assert((bigint("0") - bigint("46")).to_string() == "-46");
        assert((bigint("50") - bigint("50")).to_string() == "0");
        assert((bigint("482847") - bigint("89787941")).to_string() == "-89305094");
        assert((bigint("6828") - bigint("1")).to_string() == "6827");
        assert((bigint("100") - bigint("50")).to_string() == "50");
        assert((bigint("42") - bigint("49")).to_string() == "-7");
        assert((bigint("100") - bigint("5")) == 95);
        assert((bigint("-100") - bigint("-5")) == -95);
        bigint sb1 = 200;
        sb1 -= 40;
        assert(sb1 == 160);
        sb1 = sb1 - 180;
        assert(sb1 == "-20");
        sb1 -= bigint{ "20" };
        assert(sb1 == bigint(-40));

        //Multiplication
        assert((bigint("4") * bigint("12")).to_string() == "48");
        assert((bigint("3002") * bigint("1")).to_string() == "3002");
        assert((bigint("99") * bigint("0")).to_string() == "0");
        assert((bigint("-5") * bigint("5")).to_string() == "-25");
        assert((bigint("-33") * bigint("-2")).to_string() == "66");
        assert((bigint("283") * bigint("382871")).to_string() == "108352493");
        bigint ml1 = 4;
        ml1 *= 6;
        assert(ml1 == "24");
        ml1 = bigint(5) * 6;
        assert(ml1 == 30);
        ml1 *= "5000"_big;
        assert(ml1 == 150000);

        //Division
        assert(bigint("25") / (bigint("5")) == 5);
        assert(bigint("48") / (bigint("6")) == 8);
        assert(bigint("100") / (bigint("5")) == 20);
        bigint dv1 = 100;
        dv1 /= 25;
        assert(dv1 == 4);
        dv1 = dv1 / dv1;
        assert(dv1 == 1);
        dv1 /= 1;
        assert(dv1 == 1);
        dv1 = -5;
        dv1 /= 5;
        assert(dv1 == -1);
        dv1 = 3000;
        dv1 /= 300;
        assert(dv1 == 10);
        dv1 = 25485;
        dv1 /= 5;
        assert(dv1 == "5097");

        //Exponentiation
        assert(pow(bigint("2"), 3).to_string() == "8");
        assert(pow(bigint("1"), 38).to_string() == "1");
        assert(pow(bigint("5"), 2).to_string() == "25");
        assert(pow(bigint("10"), 10).to_string() == "10000000000");
        assert(pow(bigint("5"), 1).to_string() == "5");
        assert(pow(bigint("5"), 0).to_string() == "1");
        assert(pow(bigint("-5"), 2).to_string() == "25");

        //Equals
        assert(bigint("4") == bigint("4"));
        assert(bigint("-3") == bigint("-3"));
        assert(bigint("0") == bigint("0"));
        assert(bigint("938283828178273") == bigint("938283828178273"));

        //Greater than
        assert(bigint("5") > bigint("2"));
        assert(bigint("30") > bigint("-40"));
        assert(bigint("-5") > bigint("-10"));
        assert(bigint("0") > bigint("-1"));

        //Less than
        assert(bigint("10") < bigint("20"));
        assert(bigint("-5") < bigint("0"));
        assert(bigint("30") < bigint("30000"));

        //Greater than or equal to
        assert(bigint("5") >= bigint("0"));
        assert(bigint("-5") >= bigint("-5"));
        assert(bigint("-5") >= bigint("-10"));
        assert(bigint("0") >= bigint("0"));
        assert(bigint("32") >= bigint("-32"));
        assert(bigint("2") >= bigint("0001"));

        //Less than or equal to
        assert(bigint("5") <= bigint("10"));
        assert(bigint("0") <= bigint("0"));
        assert(bigint("-5") <= bigint("0"));
        assert(bigint("30") <= bigint("30"));
        assert(bigint("400") <= bigint("392342"));

        //Index
        assert(bigint("423")[2] == 4);
        assert(bigint("0")[0] == 0);
        assert(bigint("-5")[0] == 5);
        // At Method
        try {
            auto x =bigint(0).at(1);
        }
        catch (std::out_of_range& e) {
            std::printf("at() threw e str: %s",e.what());
        }
        //Even
        assert(bigint("426").is_even());
        assert(bigint("-20").is_even());

        //Odd
        assert(bigint("83").is_odd());
        assert(bigint("-27").is_odd());

        //Positive
        assert(bigint("38").is_positive());

        //Negative
        assert(bigint("-28382").is_negative());

        bigint a("10");
        (void)a++;
        assert(a.to_string() == "11");
        ++a;
        assert(a.to_string() == "12");
        (void)a--;
        assert(a.to_string() == "11");
        --a;
        assert(a.to_string() == "10");

        //Absolute value
        assert(abs(bigint("45")).to_string() == "45");
        assert(abs(bigint("-325")).to_string() == "325");

        //Digits
        assert(bigint("28374765").digit_count() == 8);
        assert(bigint("-3092").digit_count() == 4);

        //Assignment operator
        bigint c(10);
        c = 5;
        assert(c == 5);
        assert(c == bigint(5));
        assert(c == bigint("5"));
        c = "83833"_big;
        assert(c == 83833);
        assert(c == bigint(83833));
        assert(c == bigint("83833"));

        //Equals testing
        bigint d(40);
        assert(d == 40);
        assert(d == "40");
        assert(d == bigint("40"));
        assert(d == bigint(40));
        d = 40;
        assert(d == 40);
        d = "40";
        assert(d == 40);
    }
    TEST_CASE("abs() of big integers", "[functions][math][abs][big]")
    {
        zxshady::bigint big_num, big_num_abs;
        big_num = "-26344012632774350668411924807957373509352408071007389017455689"
            "236404655575154572365301366147824648152450898838528";
        big_num_abs = abs(big_num);
        REQUIRE(big_num_abs == -big_num);
        REQUIRE(big_num == -big_num_abs);

        big_num = "-46669885189331860769155450438595342487131957776382953797715099"
            "97938259302930977527191562288518931563246478196696588932557954671"
            "067814675528299452793998233";
        big_num_abs = abs(big_num);
        REQUIRE(big_num_abs == -big_num);
        REQUIRE(big_num == -big_num_abs);

        big_num = "157624825433230490762246168127797657567916321816555529634539929"
            "03324298954062642979937715273000088457741871468238391929188212688"
            "34763045702038940236225905428806452453734203942833503591091652111"
            "6269942";
        big_num_abs = abs(big_num);

        REQUIRE(big_num_abs == big_num);

        big_num = -bigint::pow10(12345);
        big_num_abs = abs(big_num);
        REQUIRE(big_num_abs == -big_num);
        REQUIRE(big_num == -big_num_abs);
    }

    TEST_CASE("Randomised test for big_pow10()", "[functions][math][big_pow10][random]")
    {
        std::random_device generator;
        // uniform distribution of numbers from 0 to SHRT_MAX:
        std::uniform_int_distribution<short> distribution(0, (SHRT_MAX));
        zxshady::bigint big_num;
        for (size_t i = 0; i < 20; i++) {
            short rand_exponent = distribution(generator);

            big_num = bigint::pow10(rand_exponent);
            REQUIRE(big_num.to_string() == "1" + std::string(rand_exponent, '0'));
        }
    }

    TEST_CASE("Base Initializing","[constructors]")
    {

    }
    TEST_CASE("Base cases for operators","[functions][operators]")
    {
        bigint a,b;

        REQUIRE(a==b);
        a = 12;
        b = "0xff";
        REQUIRE(a+b == 0xff + 12);

        REQUIRE(b-a == 0xff - 12);

        REQUIRE(a-b == 12 - 0xff);
    }

    TEST_CASE("Base cases for pow()", "[functions][math][pow]")
    {
        // 0^-1
        try {
            //zxshady::bigint undefined = pow(bigint{ "0" }, -1);
        }
        catch (std::logic_error& e) {
            puts(e.what());

        }
        REQUIRE(pow(bigint{ "0" }, 1) == 0);

        //REQUIRE(pow(bigint{ "1" }, -1) == 1);
        REQUIRE(pow(bigint{"1"}, 0) == 1);

        REQUIRE(pow(bigint{"1"}, 1) == 1);
        //REQUIRE(pow(bigint{"-1"}, -1) == -1);
        REQUIRE(pow(bigint{"-1"}, 0) == 1);
        REQUIRE(pow(bigint{ "-1" }, 1) == -1);
    }

    TEST_CASE("pow() with zxshady::bigint base", "[functions][math][pow]")
    {
        zxshady::bigint num = 11;
        REQUIRE(pow(num, 9) == 2357947691);
        num = -27;
        REQUIRE(pow(num, 16) == "79766443076872509863361");
        num = 174;
        REQUIRE(pow(num, 28) == "5437245617739465972266838607094505258676301045444"
            "37723753086976");
        num = -491;
        REQUIRE(pow(num, 37) == "-371548240109793740704290562371939047874194757847"
            "1192936297400283387941819501964796887819867312404731");
        num = 1023;
        REQUIRE(pow(num, 46) == "2846290024820164306745254023122897258831206069504"
            "52318727969325369627171330538069500151925066426445843470621595871"
            "3707938963481435378239489");
        num = 4375;
        REQUIRE(pow(num, 123) == "692310717819222208645161329095927823458583641636"
            "03066687435794320395447971353935391209371822096875547147598543448"
            "58063013174221664072185139386716890286845284676429789376563237238"
            "21459181898500562615895709403045506146216402709302426975054984542"
            "82379017830901385909952557690741598760150017980773176849657658609"
            "10586786816268615033415630313626104634807563914442755557232584312"
            "26509067923785919654249933510544497833327781677326129283756017684"
            "9365234375");

        REQUIRE(pow(bigint(73),1290) == "4858358466355052195809308400394723765095398344391015469071968465758049538275716806315539372769380867868820589167267860264095819930086336421959675773559634774911108474583168219029083619137055111244083248086521610288535321060619101806376953726529220943408390746905479334162894535438469571959836293690186132113139689624183008319841421555445438553868988822489506526564173083561066355737166361912472921712099696814340913334652837554413011986024242191415345044486325943914314610182477248690734599674557003962956324723493353611825911934970190144534481198918437273500253252439147674549685461222566015382238770580438545047876111241698927400462396397926572899249500059115485736299194951172011275944533050421088438362576810525950632833307263625649302834308983295105740257561734912439950697315237024885224549151082351766757440279373217729807435656042492785087188468684198975844046421784944334167200019301551503361043617763189464427380679203631826902003818673209593587845179876407068462393190247481068238123816428763236455047390806433009411895828239319941128334870353785350624727429228011808246769780418644541861293326747752974415529122216743845047702497554795267091766845620575406582869555327174273683822770409857695844187144704778538262274069640078827808168013530679074049026978946251961441240887635294202919989783166466958974723857916662527550008371344142290343635279001233065552701046131948578627151374171426378256458120427674152874126368624391718826744346279407925159109447719665115850569557309938280716342548376846342996858301552028092540974982550587193499135732620025926059374912164393940382463344135733526488127081913620356075532718757439769771877526969414990552098695913603676925381311129165299497634153594262405739186377986550932529346107975015239389805765559679193808997708195497814135758720945094917858426585156404432488186112739499084517099630641009569619197344518629035949257234092601481965878398370707572495367571657053803794822878720824980826200929431785475695108993323255678724594245650796912393976082081424705701842995898918920863842714089580454856866285988951891618523399433022731300377261667013730877014046099545216150829260260404695258139558706603367191114992913216579194786555786242187236603717077361087312264921085811654547564969426713830010491754365791873279759695487931682232466142391318631517084258212349257538856637842091902482680406895698210220276135526753233847411527054885323489333176849");

        REQUIRE(pow(bigint(73),1290) == "0x1d513b64f47a0e5fc5d42d9213e5158087697bb28c1ec09921a60fbfb7310af948cc9fcb83d9eb2e54d55e85f4d032e443fcd771609a5841d85770291b8c6f69f6de1acefe93cf4100070fd5f29826e4439360f3907a7ca796e7cbdb2a2a7dc7bc0d809fcbae3a0b260d5d56b18da2c8bcf376d3e11e986997bddfe129bc2b76f2ca43b9573b381411284b1c3c46e8daad467d42f1ec23e58a54cd732f7db29c22b8931b208e06ac076bffadc156df507dd88aa9b6ecbfa7df05dbdf75db6b8ba6d3cb7843da4644e26b71cbad63ee2e934055991e967b38d1638a78672e7ce0b7e1f46ed7a0b18629ed1d4e0865ea86a34da4527309558b563356deebc699803c67896f9f31b3f8ddaa87c5a9ec469d98f825027bd6fe7afae459033eba7990e323194c4e5cb1c6d52d7eb4a67129f731288f52358865afcfdce859f83ff6dfd3bda810318ee2d6603b9e4a510e90b4403c2e1e283634a49d404189759dbe4e9616ddba234debb56805aebc0592c57269ba70f17740a5b7fed23a1d455c96e780512470ffd9978ec7401eb34014158d2c1bfe093e1a55008b9996b132c6b68c61d1012373ec18d88e5987afc872bf5136c07c5bc79042af478b54b3dcd678962e62a94f5910f1fa5b636b6b2e084619969eb6557d1bec9f75f41cd32df619b3533e933d1720e04ed22da08d52f1df1943457db53c7dac2699052a618d6ba9adf2a0e4caa7c0dec216793b82ae87d94129d2b7ff7b34fb266303b0e72771fc65541c6a60f6e2b8ecdf524ceaa3a61cce5e68dd4192ffea61aebd2a589e8b0baf08d8c98f47f40ee7a2c7b2b57a26d0e8f1a33badfddda613b21003a14f2d67b6a2cb2e598ffe2bc493b9f78d5ec76859e12c2c5c8b5532d804acbfd67ebbd04c5804f031b299ac00dfd7a6470d4087f02ce61ea807e737121a92179387e87ee2dfb21943e356bc0cc7a55da76405349f6ced2017ebab38b1bc775d2293a8bfa39da33ccc42c1af393d57d966412760c534df170a4c5721a7a0835b04d85dc7025870010b8421939ec2586b3a135e30123e5ef131b39f57977724ac8c47636c06903ecd02d2f5207725ca1e98cf88933be445375d8ee84d0fef74851500d955c555e941fe217e4ee76e11c9a85bbe79ce758bc262a3f8fb0a24ee630211da1a3daeede7c0eb3658e4b93d15c7819d563d0276d9a5a1b3258d7be0d579f13625e4f361769b123f1d9debe7a5033c19b23cd75b49aca1c6bc4dba7ce335fab7d6fcc60278d0d1403215dd6a296eda99fe1be3dfbd23c8b743e8778e073dfd1479529b1cb9f8f53438d83beb29edff5b259d69aca82aa84c48a28d798d67f0744e8c2dea5ea8067ed5fe50becc942e6a91ca8549b193503163ee699304e3d9e9160ffef43ca7b6a11");

        // in binary 
        REQUIRE(pow(bigint(14792),232) == "0B1101110011010110100101101011101100010001100000101100100101110111011011111001110001011011100110011000001101101100000111011101111001011110100111010011001000010000000001001010110101111001010101111111010111110101100011011010011111110000111011010100000110001111001110111010110011100011010101000011101110011011000101010111100000110010101000011011110000010110101101010111011000000101101000101110101001100000000111101010010101011000000100000010100101000000010000101010100001010100001001110011000101100000011001110000000000011111001010000100110000000101010010000101110111011110011000011000001000011111101111101010010111001000011011101010000111010010100110000110001001001010001010011000010100010010110110101001000100001000011010110011011010000101100110010101011001110010111001100011101000101011110100110111111010000110101000101100100101011001110100100100010011000110111101001110111010101111110100101000010101111111001101110101011010100011010000010001101001111111010010000100011011101001000001111111100101000010011011011000010111000100110010110100011100111001100000110111100001000100001101111001001111110011001001010101100010110101001000010110011000000101000011111111010000101011011100000001110111001100010000111111110110111111011010001101001110111101111001000111100000010100011110011111010000010101101100001000101001001101101101110001100110111001011000000011100101010010000110010100100011001001100001000001110111110101110110101001111011000001000101101101010010011101101010101101101011011100100001101100101110000110011011101011011110101110110100111011010000000010110011111001010100011100110011110000110110100101001000100001001011101001001000000011110010011011111001110110111110101100000010010100101011010000111111011110110000010000111101001000111011010111000001001110001101110111011101001111111110011000011110001111010000001001001001110110011000101111010001000100011001011111110111011000111001001111001010110111001111010101101001111111110110100001001101000111101000001001011110100001001100111001100111101111011011111010111111010111000100011010011000111101010000111011010010101001010010011110000101000011111000000000000111001101100111110101000000101000010101101100111111001100011111111000010011010100110111010111011100111011000110011010100111100110001010110001011100011001100110010100011101111110101000100011100100001010010001101110101000011011011001000111100011000100010110001000000100010110111011000010100010100011110101001100110001101100110010000001110100100010100101001110011110000000111000111010000011011100010011010111000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    }
    
    TEST_CASE("pow() with integer base", "[functions][math][pow][integer]")
    {
        bigint num = 8;
        REQUIRE(pow(num, 243) == "282401395870821749694910884220462786335135391185"
            "15775246834019308626938303611984999058739209952299969708978654982"
            "83996578123296865878390947626553088486946106430796091482716120572"
            "632072492703527723757359478834530365734912");
        num = 17;
        REQUIRE(pow(num, 180) == "302556054495901008313865017376163772741128463628"
            "48452051025575455414421375942025507613042229017536765822671493394"
            "40537573230160088368322808488281205414553961324252387686780177230"
            "68038205330113241354524959622306238937774401");

        num = -36;
        REQUIRE(pow(num, 101) == "-15365708057232986428691096094675854364347594832"
            "76161946183724684166406546378631060468659701626725550268526135680"
            "0340673914360748658633428725824561309114433536");

        REQUIRE(pow(bigint{ 729LL }, 76) == "36922589523355488684862534309606828646354858539"
            "33963934010870460686027831695461222301192671449678638056692404147"
            "21568131470582838371860677594255943413907726272489256364738940659"
            "00906894946778020270362243511617241359521");
        REQUIRE(pow(bigint{ -1850LL }, 58) == "313299893588550378338834564511940091616782930"
            "14291813764729089755365285020953460978062715434205864895034210348"
            "96746277809143066406250000000000000000000000000000000000000000000"
            "000000000000000");
        REQUIRE(pow(bigint{ 24137LL }, 41) == "489795632015614011122175981066754073282443339"
            "39948728458482169347805105319057028172299652278979515526555801382"
            "58256121841619802351764133789272763824594104080192254353037855728"
            "51337");
    }

    TEST_CASE("pow() with string base", "[functions][math][pow][string]")
    {
        bigint num{ "15" };
        REQUIRE(pow(num, 123) == "456273098478477754404871005449560512605808364897"
            "24452716204137204571502556329707022452196723171746311478388924420"
            "81260014674626290798187255859375");
        num = "-88";
        REQUIRE(pow(num, 164) == "785521782697551570945213155401580125421956658055"
            "48056598286634052504685584559003178242649146182814285551395798811"
            "29890198190577602637561754093202322057553543500267662416964728626"
            "54494995542956033916131308760564271808039033231156701241088535498"
            "29292323451578980827379278634804533636440616602433612705235954452"
            "67842727936");
        num = "673";
        REQUIRE(pow(num, 52) == "1139681082871140385901008482666731136077952234110"
            "74666715735678345006314459593056186063405561967228331677630675442"
            "0305995142114939236011090500616321");

        REQUIRE(pow(bigint("-5910"), 43) == "-15075151241473776392006616026709431326069411"
            "51733898273297153829578658680990568795886085039857755798881149863"
            "719608986710000000000000000000000000000000000000000000");
        REQUIRE(pow(bigint("23487"), 30) == "133298859471971822367112923632999128200430350"
            "37609890954320285896334527706015249826664957980123680633865514789"
            "2297850894367261618049");
        REQUIRE(pow(bigint("524356"), 27) == "26909679757739832146190247401059923715257013"
            "08862990907940498760592041482791966715057053380053636634477979263"
            "4601932346249911644260403539535769743430516736");
    }

    TEST_CASE("Base cases for sqrt()", "[functions][math][sqrt]")
    {
        zxshady::bigint num = 0;
        REQUIRE(sqrt(num) == 0);
        num = 1;
        REQUIRE(sqrt(num) == 1);
        num = 3;
        REQUIRE(sqrt(num) == 1);
        num = 4;
        REQUIRE(sqrt(num) == 2);
        num = 9;
        REQUIRE(sqrt(num) == 3);
        num = 10;
        REQUIRE(sqrt(num) == 3);

        num = -1;
        try {
            zxshady::bigint undefined = sqrt(num);
        }
        catch (std::logic_error& e) {
            static_cast<void>(e);
            //CHECK(e.what() == std::string("Cannot compute square root of a negative integer"));
        }
    }

    TEST_CASE("sqrt() of perfect squares", "[functions][math][sqrt]")
    {
        std::map<int, int> sqrt_map = {
            {4,        2},
            {9,        3},
            {16,       4},
            {25,       5},
            {36,       6},
            {49,       7},
            {64,       8},
            {81,       9},
            {100,      10},
            {121,      11},
            {144,      12},
            {169,      13},
            {196,      14},
            {225,      15},
            {256,      16},
            {1024,     32},
            {1046529,  1023},
            {1048576,  1024},
            {6086089,  2467},
            {6091024,  2468},
            {11703241, 3421},
            {11710084, 3422},
            {25969216, 5096},
            {25979409, 5097},
        };

        for (auto sqrt_pair : sqrt_map) {
            REQUIRE(sqrt(zxshady::bigint(sqrt_pair.first)) == sqrt_pair.second);
        }
    }

    TEST_CASE("Randomised test for sqrt()", "[functions][math][sqrt][random]")
    {
        std::random_device generator;
        std::uniform_int_distribution<long long> distribution(0, (LLONG_MAX));
        for (size_t i = 0; i < 100; i++) {
            long long rand_num = distribution(generator);
        }
    }
    TEST_CASE("sqrt() of big integers", "[functions][math][sqrt][big]")
    {
        zxshady::bigint num = 81224;
        REQUIRE(sqrt(num) == 284);

        num = 2802961249;
        REQUIRE(sqrt(num) == 52943);

        num = "24465964562071830625";
        REQUIRE(sqrt(num) == 4946308175);

        num = "3479680743635798438602889954485038919559460388450";
        REQUIRE(sqrt(num) == "1865390238967653234193278");

        num = "34194353721643989214042055879801028224577442242064";
        REQUIRE(sqrt(num) == "5847593840345273947234580");

        num = "4713365177845202127969377413966864031679429777731216458034793396477"
            "37161";
        REQUIRE(sqrt(num) == "686539523832765372419381874316283619");

        num = "3049530077087685856458276451272326319423080138439655574506776710873"
            "91006548030000";
        REQUIRE(sqrt(num) == "17462903759362833573945713140457169848645");

        num = "1208006135370083192366171536761431070551010018430168557130297136814"
            "124413249425830934603622833272936";
        REQUIRE(sqrt(num) == "34756382656572349234723593456269236723897234598723");

        num = "5396259133865814201706389193200689822711586341557906061174319731059"
            "5624546190598499053664826956154825894621643111076086259061529893859"
            "072147579231493639756755211658494550031529896427679216992311649649";
        REQUIRE(sqrt(num) == "7345923450367430967234547374457324572368945609486134"
            "098523490875239876209348752098273450239487562343");
    }

    auto gcd_ = [](long long a, long long b)
        {
            if (!b) // using operator! for == 0 becuase it is faster since it is hardcoded!
                return abs(a);    // gcd(a, 0) = |a|
            if (!a) // using operator! for == 0 becuase it is faster since it is hardcoded!
                return abs(b);    // gcd(0, a) = |a|

            a = abs(a);
            b = abs(b);

            auto remainder = b;
            while (remainder) {
                remainder = a % b;
                a = b;
                b = remainder;
            }
            return a;
        };

    auto lcm_ = [&](long long a, long long b)
        {
            if (!a || !b) // using negation operator! to check for == 0 since it is hardcoded it is faster!
                return decltype(abs(a * b) / gcd_(a, b)){};
            return abs(a * b) / gcd_(a, b);
        };

    TEST_CASE("Randomised test for gcd()", "[functions][math][gcd][random]")
    {
        std::random_device generator;
        // uniform distribution of numbers from LLONG_MIN to LLONG_MAX:
        std::uniform_int_distribution<long long> distribution((LLONG_MIN), (LLONG_MAX));
        for (size_t i = 0; i < 100; i++) {
            long long integer1 = distribution(generator);
            long long integer2 = distribution(generator);


            zxshady::bigint big_int1 = integer1;
            zxshady::bigint big_int2 = integer2;
            std::string integer2_str = std::to_string(integer2);

            long long expected_gcd = gcd_(integer1, integer2);
            REQUIRE(gcd(big_int1, big_int2) == expected_gcd);
            REQUIRE(gcd(big_int1, integer2) == expected_gcd);
            REQUIRE(gcd(big_int1, bigint{ integer2_str }) == expected_gcd);
            REQUIRE(gcd(big_int2, big_int1) == expected_gcd);
            REQUIRE(gcd(integer2, big_int1) == expected_gcd);
            REQUIRE(gcd(bigint{ integer2_str }, big_int1) == expected_gcd);
        }
    }

    TEST_CASE("Base cases for gcd()", "[functions][math][gcd]")
    {
        zxshady::bigint num = 123456789;
        REQUIRE(gcd(num, 0) == num);
        REQUIRE(gcd(0, -num) == num);

        num = "-5912497820419707218240478194215164153";
        REQUIRE(gcd(num, 0) == -num);
        REQUIRE(gcd(0, -num) == -num);
    }
    TEST_CASE("gcd() of big integers", "[functions][math][gcd][big]")
    {
        zxshady::bigint num1, num2;
        num1 = "-28701459619301513978950179078087383496799625608342360911660546962"
            "6226480898832387914378647227381298172400875321359626526";
        num2 = "259676874116728507995615797792043346565959939008390306340060244299"
            "957115837743525129541487196215617038210022066763254690980408296383116"
            "7438735691920771807553565900345087703773104";
        REQUIRE(gcd(num1, num2) == "2870145961930151397895017907808738349679962560"
            "834236091166054696262264808988323879143786472273812981724008753213596"
            "26526");

        num1 = "502709688287865084979589372814644735042152904730080078588488501749"
            "304853656848471698577996697331106182773782819152187924589506119423139"
            "3449809274726857526593076";
        num2 = "229801173305277725653531537012213553527219194341261839531874161152"
            "120471652370285152798196993513652596100648576424699198031891109543456"
            "40291279915526420792768837307589165628581578497517531497793276";
        REQUIRE(gcd(num1, num2) == "5027096882878650849795893728146447350421529047"
            "300800785884885017493048536568484716985779966973311061827737828191521"
            "879245895061194231393449809274726857526593076");

        num1 = "179808363116887720418632899034744992715140532806272754227625836421"
            "314089790834938436981704176026712384458366664389143163105529357675898"
            "863842312404914634799999961195725750525719410167387438425426347823552"
            "0875839344564111160862825105725176379138229960";
        num2 = "360678681586952249424916997435717051409065719201628568070971812924"
            "175497184487423342549160121583044936658711604011498293651939726933392"
            "310411364541796522417366059941501171344834807935292044485515752515846"
            "5050742997335518052240435760284538105240916712";
        REQUIRE(gcd(num1, num2) == "2967318005406102180152352893326198207229760677"
            "892175934946549883420397056138122377874078159295664869224987233341800"
            "165838235976741016342171914264316392");
    }

    TEST_CASE("Randomised test for lcm()", "[functions][math][lcm][random]")
    {
        std::random_device generator;
        // uniform distribution of numbers from -3037000499 to 3037000499:
        std::uniform_int_distribution<long long> distribution((-3037000499),
            (3037000499));
        for (size_t i = 0; i < 100; i++) {
            long long integer1 = distribution(generator);
            long long integer2 = distribution(generator);


            zxshady::bigint big_int1 = integer1;
            zxshady::bigint big_int2 = integer2;
            std::string integer2_str = std::to_string(integer2);

            long long expected_lcm = lcm_(integer1, integer2);
            REQUIRE(lcm(big_int1, big_int2) == expected_lcm);
            REQUIRE(lcm(big_int1, integer2) == expected_lcm);
            REQUIRE(lcm(big_int1, bigint{ integer2_str }) == expected_lcm);
            REQUIRE(lcm(big_int2, big_int1) == expected_lcm);
            REQUIRE(lcm(integer2, big_int1) == expected_lcm);
            REQUIRE(lcm(bigint{ integer2_str }, big_int1) == expected_lcm);
        }
    }

    TEST_CASE("Base cases for lcm()", "[functions][math][lcm]")
    {
        zxshady::bigint num = -9876543210;
        REQUIRE(lcm(num, 0) == 0);
        REQUIRE(lcm(0, -num) == 0);

        num = "219019024102157019457158092713173121573";
        REQUIRE(lcm(num, 0) == 0);
        REQUIRE(lcm(0, -num) == 0);
    }
    
    TEST_CASE("lcm()of big integers", "[functions][math][lcm][big]")
    {
        zxshady::bigint num1, num2;
        num1 = "-633293162545235516827204921608484039876880488546867238715155";
        num2 = "751467462681527802564845512694233047131278025010963143942272";
        REQUIRE(lcm(num1, num2) == "3660763123010988395932260487955625105886372221"
            "087113492935131297854937091253061105429105293659470657022754363775165"
            "6320");

        num1 = "431725782679516687812397269094148164228788688988330296960502266891"
            "277126317871224101300816470466899";
        num2 = "210204267611934443161921831201103550498213144947220752751829704138"
            "0385675074011446417186911955170127";
        REQUIRE(lcm(num1, num2) == "9075060195733697769850772263661839623306634656"
            "150065383714705331906315350838857000789836809159490190572469790732585"
            "553705831078778137138399554273866158564526814198650782346897029240548"
            "58548667126173");

        num1 = "486478183750203693027954972176960357768543354407814554669357573593"
            "9153465244560450505234315632071983";
        num2 = "170392478191571803530259651455950875922139049689136212457315013318"
            "8135167718854241496296593603612002";
        REQUIRE(lcm(num1, num2) == "8289222331533204329893614622858422873253500551"
            "773165023583543979273894307090377362282997909371974857157338418233214"
            "533220692127153044311875258011747917053108027629278373174251200266431"
            "428784066739966");
    }
}